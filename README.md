
# 电话唤醒CPU机制

为什么要写这套机制
----------
Andorid 平台上，手机接收推送通知的送达率往往不能得到保障。<br>
不同与IPhone平台的统一推送策略，Andorid平台的每个应用通常都需要维护自己的一条与自己服务器的Socket长连接（第三方如极光推送原理也是这样），推送消息通过这条Socket来传递。由于移动设备的网络环境错综复杂，并不能保证这条Socket长连接能够稳定不断，所以服务器在利用Socket推送通知之前，都需要移动设备通过心跳机制进对移动设备进行判断，（比如说移动设备需要和服务器每隔1分钟通信一次（就是所谓的心跳），如果超过3分钟没有通信则判断移动设备处于离线，取消推送）。移动设备通过Socket与服务器进行通讯，是需要CPU来完成的操作。然而CPU是移动设备的耗电大户，一般手机在熄屏后选择将CPU调节至睡眠状态，而频繁的Socket联网操作会阻碍CPU进入睡眠。这就导致了手机耗电量迅速增加的情况。<br>
针对这种耗电情况，各个手机厂商对自己定制的Android系统ROM都有相对应的定制。比如MIUI，在手机熄屏后，会强制CPU进入睡眠状态，原计划的Socket心跳比如每分钟与服务器通信一次，则会被延迟。直到某个底层或系统级应用需要联网操作时才会唤醒CPU，而我们自己的应用则没有这样唤醒CPU的权限。<br>
(你可能会问：微信QQ这样的应用是如何做到熄屏仍然能收到推送的？答：白名单...你懂的)<br>
如果我们整个项目的业务逻辑都基于推送，如果推送不能及时送达会造成业务上的麻烦的话，那么这些如MIUI定制的Rom造成CPU的睡眠真的非常令人头疼。<br>


然而应该怎么做
--------
首先，我们们先要知道手机处理器的构成与运作原理。一般手机有两种处理器，一种是AP（Application Processor），一种是BP（Baseband Processor），前者顾名思义是用来运行应用的，而后者是我们我们打电话发短信以及上网时调用的处理器，通信协议栈就运行于BP的RTOS之上。BP在大部分场合是不会休眠的，因为其能耗非常非常低（非通话状态时5mA以下，AP在50mA以上）。所以，主要解决方案就是如何通过BP来唤醒AP<br>
我的第一个想法就是利用android的时钟机制，也就是AlarmManager。<br>
AlarmManager是一种非常准确的机制，最重要的是它并不是工作在CPU中的（也许是工作在BaseBand，没细究），利用它的setRepeating()方法可以准确的唤醒CPU，并且提供一个不算短的时间供CPU处理数据。如果数据量比较大的情况下还可以使用WeakLock来阻止CPU进入睡眠状态。<br>

这个方案在大部分手机的确可行。然而我在测试中发现MIUI特地为时钟机制设了一个门槛，如果我们设置时钟循环唤醒CPU的时间小于5分钟，等到手机熄屏以后，会被逐渐调整到5分钟。也就是如果我们在MIUI上的Socket心跳应该设置到5分钟以上。这对于想精确掌控客户端网络状态的项目简直不可接受...这个问题的确困扰我很久，搜了很多资料也没有一个完美的解决方案。问题就卡在大部分代码是运行在CPU上的，但是CPU睡眠了代码也处于阻塞状态并不立即执行，如何不靠代码来唤醒CPU？<br>


一个歪招
--------
还是要回到如何利用BP唤醒AP的思路上。两种方案比较靠谱，即通过短信或者打电话这种基础的操作，迫使BP唤醒AP来进行工作。<br>
问题是短信收费，用户量大的时候也的确会产生不小的费用。打电话的话如果不接电话就不会产生费用。所以，选择打电话的方案。<br>
于是一个非常简单的Demo就出来了，原理是当有推送，服务端只需要使用一个特定电话给客户端打电话，此时CPU唤醒，客户端监听每一个来电，如果发现号码与服务端一值，则立即挂断这个电话，并且删除通话记录中的这个电话的数据，同时主动向服务器PULL一遍推送数据，成功后显示在手机上。经测试，如果在熄灭屏幕的状态下，客户端的体验就是屏幕亮了一下，然后再出现了一条通知。及时兼经济，MIUI的问题迎刃而解
